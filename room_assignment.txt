reset;

option omit_zero_rows 1;
option randseed'';
# option solver './cplex';

# Room assignment problem
#


# time slots per day
param TpD ; 

# days per week
param DpW ;


set rooms ;
set courses ;
set timeslots := {0..(TpD * DpW) - 1};
set departments ;

# Raumkapazitaet
param capacity{r in rooms};

# base room per department
param departmentHQ{d in departments} ;


# Kursbelegung
param maxParticipants{c in courses} := round(Uniform(5,10));

# Anzahl Haeufigkeit eines Kurses pro Woche
param courseFrequency{c in courses}; # := round(Uniform(1,2));

# Lehrstuhlzuteilung
param departmentAssign{c in courses} ;

param departmentBin{d in departments, c in courses} := if departmentAssign[c] = d then 1 else 0;

var x {c in courses, r in rooms, t in timeslots} binary;

var MaxSimCoursesPerSlot integer;


# Keine Doppelbelegung Raum, Slots
subject to NB1{r in rooms, t in timeslots}:
    sum{c in courses} x[c,r,t] <= 1;

# Hauufigkeit eines Kurses pro Woche
subject to NB2{c in courses}:
    sum{r in rooms, t in timeslots} x[c,r,t] = courseFrequency[c];

# Raumkapazitaet beachten
subject to NB3{c in courses, r in rooms, t in timeslots}:
    x[c,r,t] * maxParticipants[c] <= x[c,r,t] * capacity[r];

# Kurse nicht gleichzeitig in verschiedenen Raeumen
subject to NB5{c in courses, t in timeslots}:
    sum{r in rooms} x[c,r,t] <= 1;

# Lehrveranstaltung nicht am gleichen Tag
subject to NB6{ d in 0..DpW-1, c in courses }:
    sum { r in rooms, t in 0..TpD-1 } x[c,r,d*TpD+t] <= 1;

# Kurse nahe des department HQs
# subject to NB7 {d in departments, r in rooms, t in timeslots}:
#    x[departmentAssign[c],r,t] * departmentBin[d,c] * r >= departmentHQ[d];
    
# Kurse nahe des department HQs
subject to NB71 {c in courses, r in rooms, t in timeslots}:
    x[c,r,t] * r >= x[c,r,t] * departmentHQ[departmentAssign[c]];

# Kurse nur im Geb√§ude des department HQ
subject to NB72 {c in courses, r in rooms, t in timeslots}:
    x[c,r,t] * r <= x[c,r,t] * (departmentHQ[departmentAssign[c]] + 1000);




# Departments not at same timeslot
subject to MINDEPASS{t in timeslots, d in departments}:
        sum{r in rooms, c in courses}
            departmentBin[d, c] * x[c, r, t] <= MaxSimCoursesPerSlot;

# minimize MAXDEP: MaxSimCoursesPerSlot;



# Occupancy
param occupancy{c in courses, r in rooms} := 1.0*maxParticipants[c]/capacity[r];
param EventsTotal := sum{c in courses} courseFrequency[c];

#maximize ROOM_OCCUPANCY: (sum{c in courses, r in rooms, t in timeslots} x[c, r, t] * occupancy[c, r]) / EventsTotal;

# Occupancy Timeslots
# the thing with the quetschvariablen
var minCoursesPerSlot integer;
var maxCoursesPerSlot integer;

subject to LOWER_BOUND{t in timeslots}: (sum{c in courses, r in rooms} x[c, r, t]) >= minCoursesPerSlot;
subject to UPPER_BOUND{t in timeslots}: (sum{c in courses, r in rooms} x[c, r, t]) <= maxCoursesPerSlot;

#minimize SLOT_SPREAD: maxCoursesPerSlot - minCoursesPerSlot;

## optional: add weights
## objectve: n * upper_bound - m * lower_bound


# Non-Linear approach to optimize occupancy  (working, but slow)
# minimize LP: sum{t in timeslots} ((sum{c in courses, r in rooms} x[c, r, t]) - 2)^2;


## Combine!
# minimize ALL: 1/2 * (maxCoursesPerSlot - minCoursesPerSlot) + (sum{c in courses, r in rooms, t in timeslots} x[c, r, t] * (1-occupancy[c, r])) / EventsTotal;


solve;


# auslastung der timeslots
# var auslastung{t in timeslots} := sum{c in courses, r in rooms} x[c, r, t];

display x; # display capacity; display maxParticipants; display courseFrequency;

# display occupancy;

display courses;

display rooms;

display maxCoursesPerSlot;
display minCoursesPerSlot;

display MaxSimCoursesPerSlot;


display departmentAssign;

display departmentHQ;

#end;
