reset;

option omit_zero_rows 1;
option randseed'';
# option solver './cplex';

# Room assignment problem
#


# time slots per day
param TpD := 4; 

# days per week
param DpW := 4;


set rooms := {1..2};
set courses := {1..4};
set timeslots := {0..(TpD * DpW) - 1};
set departments := {1..3};

# Raumkapazitaet
param capacity{r in rooms};


# Kursbelegung
param maxParticipants{c in courses} := round(Uniform(5,10));

# Anzahl Haeufigkeit eines Kurses pro Woche
param courseFrequency{c in courses}; # := round(Uniform(1,2));

# Lehrstuhlzuteilung
param departmentAssign{c in courses} := round(Uniform(0.5,3.5));

var x {c in courses, r in rooms, t in timeslots} binary;

# Keine Doppelbelegung Raum, Slots
subject to NB1{r in rooms, t in timeslots}:
    sum{c in courses} x[c,r,t] <= 1;

# Hauufigkeit eines Kurses pro Woche
subject to NB2{c in courses}:
    sum{r in rooms, t in timeslots} x[c,r,t] = courseFrequency[c];

# Raumkapazitaet beachten
subject to NB3{c in courses, r in rooms, t in timeslots}:
    x[c,r,t] * maxParticipants[c] <= x[c,r,t] * capacity[r];

# Kurse nicht gleichzeitig in verschiedenen Raeumen
subject to NB5{c in courses, t in timeslots}:
    sum{r in rooms} x[c,r,t] <= 1;

# Lehrveranstaltung nicht am gleichen Tag
subject to NB6{ d in 0..DpW-1, c in courses }:
    sum { r in rooms, t in 0..TpD-1 } x[c,r,d*TpD+t] <= 1;


# Kurse eines Lehrstuhls nicht gleichzeitig
var xd{d in departments, t in timeslots} binary;
#subject to NB4{c in courses, t in timeslots, d in departments}:
#    sum{r in rooms} x[c,r,t] <=


# Departments not at same timeslot
var MaxSimCoursesPerSlot integer;

param departmentsBin{d in departments, c in courses} := if departmentAssign[c] = d then 1 else 0;

subject to MINDEPASS{t in timeslots, d in departments}:
        sum{r in rooms, c in courses}
            departmentsBin[d, c] * x[c, r, t] <= MaxSimCoursesPerSlot;

minimize MAXDEP: MaxSimCoursesPerSlot;



# Occupancy
param occupancy{c in courses, r in rooms} := 1.0*maxParticipants[c]/capacity[r];
param EventsTotal := sum{c in courses} courseFrequency[c];

#maximize ROOM_OCCUPANCY: (sum{c in courses, r in rooms, t in timeslots} x[c, r, t] * occupancy[c, r]) / EventsTotal;

# Occupancy Timeslots
# the thing with the quetschvariablen
var minCoursesPerSlot integer;
var maxCoursesPerSlot integer;

subject to LOWER_BOUND{t in timeslots}: (sum{c in courses, r in rooms} x[c, r, t]) >= minCoursesPerSlot;
subject to UPPER_BOUND{t in timeslots}: (sum{c in courses, r in rooms} x[c, r, t]) <= maxCoursesPerSlot;

#minimize SLOT_SPREAD: maxCoursesPerSlot - minCoursesPerSlot;

## optional: add weights
## objectve: n * upper_bound - m * lower_bound


# Non-Linear approach to optimize occupancy  (working, but slow)
# minimize LP: sum{t in timeslots} ((sum{c in courses, r in rooms} x[c, r, t]) - 2)^2;


## Combine!
# minimize ALL: 1/2 * (maxCoursesPerSlot - minCoursesPerSlot) + (sum{c in courses, r in rooms, t in timeslots} x[c, r, t] * (1-occupancy[c, r])) / EventsTotal;


solve;


# auslastung der timeslots
# var auslastung{t in timeslots} := sum{c in courses, r in rooms} x[c, r, t];

display x; # display capacity; display maxParticipants; display departmentAssign; display courseFrequency;

display occupancy;

display courses;

display rooms;

display maxCoursesPerSlot;
display minCoursesPerSlot;

#end;
